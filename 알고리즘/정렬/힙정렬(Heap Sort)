▶︎ 정의 : 완전 이진 트리의 일종인 Heap 자료 구조를 구성하고 root의 원소를 하나씩 빼내어 정렬

▶︎ 힙 정렬 방법
1. 정렬이 되지 않은 배열을 heapify를 통해 재구성
2. 재구성한 배열의 첫번째 요소를 마지막 인덱스로 옮긴 후 마지막 요소 제외하고 다시 heapify를 통해 재구성

[마지막 인덱스부터 역으로 첫번째 요소와 교채해 가며 2번 반복]

▶︎ 특징
1. Heap Sort는 추가적인 메모리를 사용하지 않고 하나의 array로 sorting을 하기 때문에 in-place 정렬이다.
2. Heapify를 통해 위치가 변경되기 때문에 not-stable 하다.
3. 시간 복잡도는 O(nlogn)이다.
  3-1. 시간 복잡도는 데이터를 넣을 때도 O(logN)이고 뺄 때도 O(logN)이라 고른 성능을 보인다.
  3-2. N개의 데이터를 모두 빼면 정렬이 되기 때문에 힙 정렬의 시간 복잡노든 O(nlogn)이다.


▶︎ 구현 코드
class Sort {
    public void ascHeapSort(int[] arr) {
        maxHeapfiy(arr, arr.length);
        for (int i = arr.length - 1; i > 0; i--) {
            swap(arr, 0, i);
            maxHeapfiy(arr, i);
        }
    }

    public void descHeapSort(int[] arr) {
        minHeapfiy(arr, arr.length);
        for (int i = arr.length - 1; i > 0; i--) {
            swap(arr, 0, i);
            minHeapfiy(arr, i);
        }
    }

    private void maxHeapfiy(int[] arr, int last) {
        for (int j = 1; j < last; j++) {
            int child = j;
            while (child > 0) {
                int parent = (child - 1) / 2;
                if (arr[child] > arr[parent]) {
                    swap(arr, parent, child);
                }
                child = parent;
            }
        }
    }

    private void minHeapfiy(int[] arr, int last) {
        for (int j = 1; j < last; j++) {
            int child = j;
            while (child > 0) {
                int parent = (child - 1) / 2;
                if (arr[child] < arr[parent]) {
                    swap(arr, parent, child);
                }
                child = parent;
            }
        }
    }

    private void swap(int[] arr, int index1, int index2) {
        int temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
}
