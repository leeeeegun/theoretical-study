▶︎ 정의 : 퀵 정렬은 병합 정렬과 비슷하게 분할 정복(Divide and Conquer) 알고리즘 하나로
        평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법

▶︎ 퀵 정렬 방법
1. 정렬이 되지 않은 배열의 1번 인덱스를 pivot으로 선택, 피벗 다음 인덱스를 Left으로 선택, 마지막 인덱스를 Right으로 선택
2. 각 조건에 맞을때 까지 Left, Right 증감
  2-1. Left 인덱스의 요소가 pivot보다 클 때 까지 Left++
  2-2. Right 인덱스의 요소가 pivot보다 작을 때 까지 Right++
3. Left와 Right 변수의 크기 비교 후 swap
  3-1. Left <= Right 일 경우(arr[Left] ← swap → arr[Right])
  3-2. Left > Right 일 경우(arr[pivot] ← swap → arr[Right])
[ pivot 기준 좌우측의 첫번째 요소를 pivot 으로 2~4번 반복한다.]

▶︎ 특징
1. 퀵정렬은 재귀적으로 정의되므로 재귀 호출에 따른 스택이 사용된다.
    이때 스택의 깊이는 n개의 우너소에 대해 logn에 비례하므로 공간 복잡도는 O(nlogn)이다.
      → 따라서 in-place 정렬이라고 하기 힘들지만, 실용적으로는 상대적으로 작은 메모리만을 사용하므로 흔히 in-place 정렬이라고 기술하기도 한다.
2. 퀵정렬은 최악의 경우 pivot 배열 내에서 가장 작은 값 또는 가장 큰 값으로 설정된다면 원소 n개에 대해서 n번,
    (n-1)번, (n-2)번...n번의 비교가 필요하므로 시간 복잡도가 O(n^2)된다.
3. 평균 시간 복잡도는 O(nlogn)으로 매우 빠르다.
  → pivot 값이 적절히 설정된다면 그 속도가 매우 빠르기 때문에 pivot 값을 잘 설정하는 것이 중요하다.
4. 퀵 정렬은 중복된 키 값이 순서대로 바뀌지 않을 수 있기 때문에 not-stable 정렬이다.


▶︎ 구현 코드
class Sort {
    public void quickSortAsc(int[] arr, int first, int last) {
        if (first >= last)
            return;

        int pivot = first;
        int left = first + 1;
        int right = last;

        while (left <= right) {
            while (left <= last && arr[left] <= arr[pivot]) {
                left++;
            }
            while (right > first && arr[right] >= arr[pivot]) {
                right--;
            }
            if (left > right) {
                swap(arr, pivot, right);
            } else {
                swap(arr, left, right);
            }
        }
        quickSortAsc(arr, first, right - 1);
        quickSortAsc(arr, right + 1, last);

    }

    public void quickSortDesc(int[] arr, int first, int last) {

        if (first >= last)
            return;

        int pivot = first;
        int left = first + 1;
        int right = last;

        while (left <= right) {
            while (left <= last && arr[left] >= arr[pivot]) {
                left++;
            }
            while (right > first && arr[right] <= arr[pivot]) {
                right--;
            }
            if (left > right) {
                swap(arr, pivot, right);
            } else {
                swap(arr, left, right);
            }
        }
        quickSortDesc(arr, first, right - 1);
        quickSortDesc(arr, right + 1, last);
    }

    public void swap(int[] arr, int index1, int index2) {
        int temp = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = temp;
    }
}
