▶ 정의 : 탐욕법(그리디) 알고리즘이란? 현재 상황에서 가장 좋은 것을 고르는 알고리즘이라 뜻한다.
         그리디 알고리즘은 동적 프로그래밍을 간단한 문제 해결에 사용하면 지나치게 많은 일을 한다는 것을 착안하여 고안되었다.
  → 그리디는 말 그대로 눈앞의 이익만 쫓는 탐욕적인 방법으로 문제를 푸는 방식이며, 최종 결과가 어떻게 될지는 생각하지 않고
    그 순간 순간마다 가장 좋아 보이는 선택을 반복해서 문제를 해결해 나간다.

▶ 여기서 최선의 선택이란?
  → 그리디 알고리즘이 추구하는 가장 좋은 것에 대해 예시를 들어 본다면...
  예시)
              시작
            /      \
          17        6
         /  \      /  \
       23    4   128   16

  → 시작 지점에서부터 시작하여 가장 큰 수를 구하는 문제가 있다고 가정한다.
    * 우리는 생각하는 가장 좋은 결과는 '시작 - 6 - 128'을 거치는 Path가 가장 큰 큰 수를 도출하는 걸 알 수 있다.
    * 그리디 알고리즘은 시작 지점부터 가장 큰 수를 얻는 Path인 '17'을 선택하게 되고 결론적으로 '시작 - 17 - 23' Path가 가장 좋다고 판단한다.

    이처럼 그리디 알고리즘은 현재 상황에서 가장 좋은 결과를 선택하는 방식이기 때문에 사용하기 위해선 간단한 문제로 나올 가능성이 매우 크다.

▶ 그리디 알고리즘 조건
  → 그리디 알고리즘을 사용하기 위해 필요한 조건은 2가지가 있다.

1. 탐욕스러운 선택 조건
  → 탐욕적인 선택은 항상 안전하다는 것이 보장되어야 한다. 여기서 '안전하다'라는 것은 해당 선택으로 인해 전체 문제의
    최적해를 반드시 도출할 수 있어야 한다는 것이다.

2. 최적 부분 구조 조건
  → 문제에 대한 최종 해결 방법이 부분 문제에 대해서도 또한 최적의 해결 방법이다라는 조건이다.
    이 말은 전체 문제의 안에는 여러 단계가 존재하고, 이 여러 단계 내의 하나 하나의 단계에 대해 최적해가 도출되어야 한다는 것이다.

그리디 알고리즘에서 고려해야 하는 상황은 값들이 서로 영향을 주면 안된다는 것을 염두에 두어야 한다.
* 우선 그리디 알고리즘이 도출한 최종 Path는 '시작 - 17 -23' 이었다.
  이때 '6' 아래의 '128'이라는 값이 있어서 Path를 변경할 수 없다는 의미다.

▶ 장/단점
  → 장점 : 단순하고 빠르다 - 구현이 간단하고 복잡한 계산 없이 빠르게 답을 찾을 수 있다.
           직관적이다 - 문제 해결 과정이 명확해서 이해하기 쉽다.

  → 단접 : 항상 정답을 보장하지 않는다 - 문제의 구조에 따라 최적의 해를 찾지 못할 수도 있다.
           정당성 증명이 어렵다 - 이 방법이 정말 최적의 해를 찾는다는 것을 증명하는 과정이 복잡할 수 있다.

-------------------------------------------------------------------------------------------------------------------------

추가 예시)
▶ 그리디 알고리즘의 핵심 아이디어
  → 매 순간의 최적해가 결국 전체의 최적해일 것이다는 아주 단순하고 낙관적인 가정에서 출발한다.
    각 단계에서 선택할 수 있는 여러 가지 옵션 중, 현재 상태에서 가장 이득이 된다고 판단되는 것을 바로 선택하는 것이다.

★ 가장 대표적인 예시로 '거스름돈 문제'를 해본다.
  → 문제: 500원, 100원, 50원, 10원짜리 동전으로 870원을 거슬러 줘야 할 때, 동전의 개수를 가장 적게 주려면 어떻게 해야 할까?

  → 그리디 알고리즘 방식의 해결

    1) 현재 거슬러 줘야 할 돈은 870원이야. 동전 중 가장 가치가 큰 500원짜리를 먼저 선택해. (1개)
      = 남은 돈: 370원

    2) 370원이 남았네. 이제 남은 동전 중 가장 가치가 큰 100원짜리를 선택해. (3개)
      = 남은 돈: 70원

    3) 70원이 남았어. 다음으로 가치가 큰 50원짜리를 선택해. (1개)
      = 남은 돈: 20원

    4) 20원이 남았으니 10원짜리를 선택하면 되겠네. (2개)
      = 남은 돈: 0원

  → 결과: 500원 1개, 100원 3개, 50원 1개, 10원 2개. 총 7개의 동전으로 해결! 이게 바로 최소 개수야.

※ 이렇게 각 단계에서 가장 좋은 선택(가장 큰 단위의 동전)을 하는 것만으로 최종적으로도 가장 좋은 결과(최소 동전 개수)를 얻었다.

▶ 그리디 알고리즘의 한계 
  → 탐욕적인 방법이 항상 정답을 보장하지는 않는다.
    눈앞의 이익이 나중에는 손해로 이어질 수 있기 때문이다.

  → 만약, 동전이 500원, 400원, 100원짜리만 있고 800원을 거슬러 줘야 한다면?
    → 그리디 방식: 가장 큰 단위인 500원짜리를 1개 내줘. 그럼 300원이 남는데, 400원이나 100원짜리로는 300원을 정확히 만들 수가 없네? 
      = 실패!
    → 최적의 해답: 사실 400원짜리 2개를 내주는 것이 정답이다.

※ 이처럼 그리디 알고리즘은 문제가 특정 조건들을 만족할 때만 최적의 해를 보장한다.

▶ 그리디 알고리즘이 통하는 조건
  1. 탐욕적 선택 속성 (Greedy Choice Property): 매 순간의 최적의 선택이 최종적으로도 최적의 해를 구성해야 한다.
     (위의 일반적인 거스름돈 문제처럼)

  2. 최적 부분 구조 (Optimal Substructure): 문제의 최적해가 그 문제의 부분 문제들의 최적해로 이루어져 있어야 한다.

이런 조건이 만족되는지 증명하기는 꽤 까다로워서, 보통은 그리디 알고리즘이 잘 통한다고 알려진 특정 유형의 문제들(최소 신장 트리, 다익스트라 알고리즘 등)에 많이 사용돼.
